package mmm.rulecmd;

import com.fs.starfarer.api.EveryFrameScript;
import com.fs.starfarer.api.Global;
import com.fs.starfarer.api.campaign.*;
import com.fs.starfarer.api.campaign.comm.IntelInfoPlugin;
import com.fs.starfarer.api.campaign.econ.MarketAPI;
import com.fs.starfarer.api.campaign.econ.MarketConditionAPI;
import com.fs.starfarer.api.campaign.rules.MemKeys;
import com.fs.starfarer.api.campaign.rules.MemoryAPI;
import com.fs.starfarer.api.characters.MarketConditionSpecAPI;
import com.fs.starfarer.api.characters.PersonAPI;
import com.fs.starfarer.api.impl.campaign.DerelictShipEntityPlugin;
import com.fs.starfarer.api.impl.campaign.fleets.RouteManager.RouteData;
import com.fs.starfarer.api.impl.campaign.ids.*;
import com.fs.starfarer.api.impl.campaign.intel.misc.BreadcrumbIntel;
import com.fs.starfarer.api.impl.campaign.procgen.themes.RouteFleetAssignmentAI;
import com.fs.starfarer.api.impl.campaign.procgen.themes.SalvageSpecialAssigner;
import com.fs.starfarer.api.impl.campaign.procgen.themes.ScavengerFleetAssignmentAI;
import com.fs.starfarer.api.impl.campaign.rulecmd.BaseCommandPlugin;
import com.fs.starfarer.api.impl.campaign.rulecmd.salvage.special.BreadcrumbSpecial;
import com.fs.starfarer.api.util.Misc;
import com.fs.starfarer.api.util.WeightedRandomPicker;
import mmm.Utils;
import mmm.missions.OrbitalMissionBase;
import org.apache.log4j.Level;
import org.apache.log4j.Logger;
import org.magiclib.util.MagicSettings;

import java.text.MessageFormat;
import java.util.*;

public class MMM_TradeIntel_CMD extends BaseCommandPlugin {
    private static final String MOD_ID = Utils.MOD_ID;
    private static final Logger log = Global.getLogger(MMM_TradeIntel_CMD.class);
    static {
        if (Utils.DEBUG) {
            log.setLevel(Level.ALL);
        }
    }

    // Settings
    // Chance that a scavenger wants to trade before reaching the ruins system. Not used for fleets not generated by
    // RuinsFleetRouteManager.
    public static final float WANTS_TO_TRADE_PROB = 0.5f;
    // Maximum search radius to search; this is used for large fleet; small/medium fleets have 1/2 and 3/4 of this value.
    public static final float MAX_SEARCH_LY = 8f;
//    public static final float MAX_SEARCH_LY = 1000f;
    // Maximum relations gain; buying intel on entities with cost will gain you this much relations.
    public static final float RELATIONS_GAIN = 20f;

    public static final String WANTS_TO_TRADE = "$mmm_tradeIntel_wantToTrade";  // Permanent once true
    public static final String TARGET_ID = "$mmm_tradeIntel_targetId";  // Permanent

    public static final String HIGHLIGHT = "$mmm_tradeIntel_highlight";
    public static final String TARGET_DESC = "$mmm_tradeIntel_targetDesc";
    public static final String CREDITS = "$mmm_tradeIntel_credits";
    public static final String CREDITS_STR = "$mmm_tradeIntel_credits_str";
    public static final String REL_REWARD = "$mmm_tradeIntel_rel_reward";

    public static final Map<String, Float> ENTITIES_COSTS =
            MagicSettings.getFloatMap(MOD_ID, "TradeIntelEntitiesCosts");
    public static final Map<String, Float> CONDITIONS_COSTS =
            MagicSettings.getFloatMap(MOD_ID, "TradeIntelConditionsCosts");
    public static final float MAX_COST =
            Math.max(Collections.max(ENTITIES_COSTS.values()), Collections.max(CONDITIONS_COSTS.values()));

    public static class TargetData {
        SectorEntityToken target;
        float cost;
        String highLight;
        String desc;
        String fullDesc;
        String subject;

        TargetData(SectorEntityToken target, float cost, String highLight, String desc, String fullDesc,
                   String subject) {
            this.target = target;
            this.cost = cost;
            this.highLight = highLight;
            this.desc = desc;
            this.fullDesc = fullDesc;
            this.subject = subject;
        }

        @Override
        public String toString() {
            return MessageFormat.format("target={0}, cost={1}, highlight={2}, desc={3}",
                    target.getName(), cost, highLight, desc);
        }
    }

    // Returns all the salvage entities with BreadcrumbIntel.
    public static Set<SectorEntityToken> getBreadcrumbIntelTargets() {
        HashSet<SectorEntityToken> result = new HashSet<>();
        for (IntelInfoPlugin curr : Global.getSector().getIntelManager().getIntel(BreadcrumbIntel.class)) {
            if (curr instanceof BreadcrumbIntel) {
                BreadcrumbIntel intel = (BreadcrumbIntel) curr;
                result.add(intel.getRemoveTrigger());
            }
        }
//        log.debug("getInvalidTargets: " + result);
        return result;
    }

    public static TargetData getTargetData(SectorEntityToken target) {
        if (target == null || !target.isAlive() || target.isExpired()) return null;  // Sanity check

        if (target instanceof PlanetAPI) {
            PlanetAPI planet = (PlanetAPI) target;
            if (planet.getMarket() == null) return null;  // Sanity check
            MarketAPI market = planet.getMarket();
            if (!Misc.hasUnexploredRuins(market)) return null;

            // See SurveyDataSpecial.initPlanetSurveyData for reference
            ArrayList<TargetData> candidates = new ArrayList<>();
            for (MarketConditionAPI condition : market.getConditions()) {
                if (CONDITIONS_COSTS.containsKey(condition.getId())) {
                    float cost = CONDITIONS_COSTS.get(condition.getId());

                    String world = planet.getSpec().getAOrAn() + " " + planet.getTypeNameWithWorld().toLowerCase();
                    String loc = BreadcrumbSpecial.getLocatedString(planet, true);
                    loc = loc.replaceFirst("located ", "");

                    MarketConditionSpecAPI spec = Global.getSettings().getMarketConditionSpec(condition.getId());

                    String name = spec.getName().toLowerCase();
                    String subject = Misc.ucFirst(spec.getName()) + " Location";
                    String desc = "a planet with " + name;
                    String fullDesc = name + " on " + world + " " + loc;

                    candidates.add(new TargetData(target, cost, name, desc, fullDesc, subject));
                }
            }
            if (candidates.isEmpty()) return null;
            return Collections.max(candidates, new Comparator<TargetData>() {
                @Override
                public int compare(TargetData o1, TargetData o2) {
                    return (int) o1.cost - (int) o2.cost;
                }
            });
        } else if (target instanceof CustomCampaignEntityAPI) {
            if (!target.hasSensorProfile() && !target.isDiscoverable()) return null;  // Already discovered

            // Determine the cost from salvageXP/rating
            String specId;
            if (target.getMemoryWithoutUpdate().contains(MemFlags.SALVAGE_SPEC_ID_OVERRIDE)) {
                specId = target.getMemoryWithoutUpdate().getString(MemFlags.SALVAGE_SPEC_ID_OVERRIDE);
            } else {
                specId = target.getCustomEntityType();
            }

            if (!ENTITIES_COSTS.containsKey(specId)) return null;

            CustomEntitySpecAPI custom = target.getCustomEntitySpec();
            if (custom == null) return null;  // Sanity check

            String highlight = custom.getNameInText();
            String desc = custom.getAOrAn() + " " + highlight;
            String name = target.getName();

            float cost = ENTITIES_COSTS.get(specId);
            if (specId.equals(Entities.WRECK)) {
                cost *= target.getSalvageXP();

                if (target.getCustomPlugin() instanceof DerelictShipEntityPlugin) {
                    DerelictShipEntityPlugin plugin = (DerelictShipEntityPlugin) target.getCustomPlugin();
                    if (plugin.getData() != null && plugin.getData().ship != null) {
                        name = plugin.getData().ship.getVariant().getHullSpec().getNameWithDesignationWithDashClass();
                        highlight = name;
                        desc = "a derelict " + name;
                    }
                }
            }
            String fullDesc = desc + " " + BreadcrumbSpecial.getLocatedString(target, true);
            return new TargetData(target, cost, highlight, desc, fullDesc, "Location: " + name);
        }
        return null;  // Sanity check
    }

    public static TargetData pickTarget(StarSystemAPI system, Set<SectorEntityToken> invalidTargets, float searchLY,
                                        Random random) {
//        system = Global.getSector().getStarSystem("gamma vassago");
//        log.debug(MessageFormat.format("pickTarget: search {0} LY from {1} system", searchLY, system.getName()));

        WeightedRandomPicker<TargetData> picker = new WeightedRandomPicker<>(random);

        List<StarSystemAPI> systems = Misc.getNearbyStarSystems(system.getCenter(), searchLY);
        for (StarSystemAPI loc : systems) {
            // See BreadcrumbSpecialCreator/AnalyzeEntityIntelCreator for reference
            for (SectorEntityToken entity : loc.getEntitiesWithTag(Tags.SALVAGEABLE)) {
                if (!entity.hasSensorProfile() && !entity.isDiscoverable()) continue;
                if (invalidTargets.contains(entity)) continue;
                if (!SalvageSpecialAssigner.BreadcrumbSpecialCreator.isLargeShipOrNonShip(entity)) continue;
                if (entity.hasTag(Tags.EXPIRES)) continue;
                if (entity.hasTag(Tags.NOT_RANDOM_MISSION_TARGET)) continue;
                if (entity.getContainingLocation() != null && entity.getContainingLocation().hasTag(Tags.THEME_HIDDEN)) continue;

                if (entity.getMemoryWithoutUpdate() != null && entity.getMemoryWithoutUpdate().getBoolean("$ttWeaponsCache")) continue;
//                if (!entity.getCustomEntityType().equals(Entities.WRECK)) continue;

//                log.debug(MessageFormat.format("Candidate salvage: name={0}, type={1}", entity.getName(), entity.getCustomEntityType()));

                TargetData data = getTargetData(entity);
                if (data == null) continue;
//                log.debug("Candidate salvageable: " + data);

                float weight = loc == system ? data.cost * 2 : data.cost;
                picker.add(data, (float) Math.pow(weight, 1.5));
            }

            if (loc.hasTag(Tags.THEME_HIDDEN)) continue;

            for (PlanetAPI planet : loc.getPlanets()) {
                if (!invalidTargets.contains(planet)) {
                    TargetData data = getTargetData(planet);
                    if (data == null) continue;
//                    log.debug("Candidate planet: " + data);

                    float weight = loc == system ? data.cost * 2 : data.cost;
                    picker.add(data, (float) Math.pow(weight, 1.5));
                }
            }
        }

        return picker.pick();
    }

    // Find the ruins star system to search from. Returns the sytem if we want to trade; otherwise returns null.
    public StarSystemAPI findRuinSystem(CampaignFleetAPI fleet, Random random) {
        // See if this is a fleet generated by RuinsFleetRouteManager in order to find the ruins theme system.
        // If so, the fleet always wants to trade in the last 2 route segments; otherwise you need to roll to find
        // out if they want to trade. If the fleet is not generated by RuinsFleetRouteManager, then they always want
        // to trade and use the closest system to search.
        ScavengerFleetAssignmentAI ai = null;
        for (EveryFrameScript script : fleet.getScripts()) {
            if (script instanceof ScavengerFleetAssignmentAI) {
                ai = (ScavengerFleetAssignmentAI) script;
                break;
            }
        }

        if (ai != null) {
            Object obj = Utils.reflectionGet(RouteFleetAssignmentAI.class, ai, "route");
            if (!(obj instanceof RouteData)) return null;
            // See RuinsFleetRouteManager.addRouteFleetIfPossible for reference.
            RouteData route = (RouteData) obj;
            if (route.getSegments().size() == 5) {
                if (route.getCurrentIndex() < 2) {
                    float roll = random.nextFloat();
                    if (roll >= WANTS_TO_TRADE_PROB) {
                        return null;
                    }
                }

                SectorEntityToken from = route.getSegments().get(2).from;
                if (from != null) {
                    return from.getStarSystem();
                } else {
                    log.error("RouteSegment.from is null");
                }
            } else {
                log.error("Unexpected RouteData segments count: " + route.getSegments().size());
            }
        }
        return Misc.getNearestStarSystem(fleet);
    }

    @Override
    public boolean execute(String ruleId, InteractionDialogAPI dialog, List<Misc.Token> params,
                           Map<String, MemoryAPI> memoryMap) {
        // Should not be called if $mmm_tradeIntel_done is set
        log.debug(MessageFormat.format("execute ruleId={0}, params={1}, this={2}", ruleId, params, this));
        if (dialog == null || params == null || params.size() != 1 || memoryMap == null ||
                memoryMap.get(MemKeys.LOCAL) == null || !(dialog.getInteractionTarget() instanceof CampaignFleetAPI) ||
                dialog.getInteractionTarget().getActivePerson() == null) {
            log.error("Failed sanity check.");
            return false;
        }

        PersonAPI person = dialog.getInteractionTarget().getActivePerson();
        MemoryAPI memory = memoryMap.get(MemKeys.LOCAL);

        if (params.get(0).getString(memoryMap).equals("accept")) {
            TargetData data = getTargetData(Global.getSector().getEntityById(memory.getString(TARGET_ID)));
            if (data == null) {
                log.error("Failed sanity check.");
                return false;
            }

            BreadcrumbIntel intel = new BreadcrumbIntel(null, data.target);
            intel.setTitle(data.subject);
            intel.setText("You purchased intel about " + data.fullDesc);
//            if (data.target instanceof PlanetAPI) {
//                intel.setShowSpecificEntity(true);
//            }
            Global.getSector().getIntelManager().addIntel(intel, false, dialog.getTextPanel());

            memory.unset(TARGET_ID);
            return true;
        }

        // If we already have a target, check to ensure that the target is still valid.
        Set<SectorEntityToken> invalid_targets = getBreadcrumbIntelTargets();
        TargetData data;
        if (memory.contains(TARGET_ID)) {
            SectorEntityToken target = Global.getSector().getEntityById(memory.getString(TARGET_ID));
            if (target == null || invalid_targets.contains(target)) {
                return true;
            }
            data = getTargetData(target);
        } else if (memory.getBoolean(WANTS_TO_TRADE)) {
            // Already bought target intel or no target.
            return true;
        } else {
            CampaignFleetAPI fleet = (CampaignFleetAPI) dialog.getInteractionTarget();
            long seed = OrbitalMissionBase.mixSeeds(Misc.getSalvageSeed(fleet), "MMM_TradeIntel_CMD".hashCode());
            Random random = new Random(seed);

            StarSystemAPI system = findRuinSystem(fleet, random);
            if (system == null) {  // We don't want to trade
                return true;
            }
            memory.set(WANTS_TO_TRADE, true);

            // Find fleet size to determine search radius, then do the search.
            FactionAPI faction = fleet.getFaction();
            if (faction == null) {
                faction = person.getFaction();
            }
            if (faction == null) {
                log.error("Fleet has no faction: " + fleet.getNameWithFaction());
                return false;
            }

            float searchLY;
            if (fleet.getName().equals(faction.getFleetTypeName(FleetTypes.SCAVENGER_SMALL))) {
                searchLY = MAX_SEARCH_LY / 2;
            } else if (fleet.getName().equals(faction.getFleetTypeName(FleetTypes.SCAVENGER_MEDIUM))) {
                searchLY = MAX_SEARCH_LY * 0.75f;
            } else if (fleet.getName().equals(faction.getFleetTypeName(FleetTypes.SCAVENGER_LARGE))) {
                searchLY = MAX_SEARCH_LY;
            } else {
                log.error("Unexpected fleet name: " + fleet.getName());
                searchLY = MAX_SEARCH_LY / 2;
            }
            data = pickTarget(system, invalid_targets, searchLY, random);
        }

        if (data == null) {
            return true;
        }
        log.debug("Target: " + data);
        memory.set(TARGET_ID, data.target.getId());

        // Now that we have a target and wants to trade, fill in the other memory tokens
        int credits = OrbitalMissionBase.getRoundNumber(data.cost);

        memory.set(HIGHLIGHT, data.highLight, 0);
        memory.set(TARGET_DESC, data.desc, 0);
        memory.set(CREDITS, credits, 0);
        memory.set(CREDITS_STR, Misc.getDGSCredits(credits), 0);
        memory.set(REL_REWARD, data.cost * RELATIONS_GAIN / MAX_COST, 0);

        return true;
    }
}